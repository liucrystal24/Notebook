# 冲刺阿里

## 一、简单介绍前端模块化，amd，cmd，commonjs，es6 的 module

![module](./img/module/module.png)

**代码模块化抽象成三个部分**：输入（import），计算（业务代码），输出（export）

**优势**：可扩展、可替换、代码重复用，多人并行开发

### ES6 moudule

```js
import a from "b";
// ...
export default c;
```

**规范：**

- 浏览器和服务器通用的模块解决方案
- 需要编译打包处理

**实现（浏览器端）：**

- 使用 babel 将 ES6 转化成 ES5
- 使用 Browserify 编译打包 js

**与 CommonJS 区别：**

- CommonJS 模块输出是值的拷贝，ES6 Moudule 模块输出是值的引用
- CommonJS 在运行时加载，ES6 Moudule 在编译时输出接口

### CommonJS

```js
const a = require("b");
// ...
module.exports = c;
```

**规范：**

- 服务器端：模块的加载时运行时同步加载
- 浏览器端：模块需要提前编译打包处理

**实现**

- 服务器端：node.js
- 浏览器端：借助 browserify

### AMD

```js
// 定义有依赖的模块
define(["md1", "md2"], function (m1, m2) {
  // ...
  return c;
});

// 引入使用模块
require(["md1", "md2"], function (m1, m1) {
  // 使用 m1、m2
});
```

**规范：**

- 专供浏览器使用，模块是异步加载的，模块使用时才会加载

**实现（浏览器端）**

- Require.js

### CMD

```js
// 定义有依赖的模块
define(function (require, exports, module) {
  // 引入依赖模块(同步)
  var m2 = require("./m2");
  // 引入模块（异步）
  require.async("./m3", function (m3) {});
  // 暴露模块
  exports.xxx = value;
});
// 引用模块
define(function (require) {
  var m2 = require("./m2");
  var m3 = require("./m3");
  m2.show();
  m3.show();
});
```

**规范：**

- 专供浏览器使用，模块是异步加载的

**实现（浏览器端）**

- Sea.js

### 总结

1）ES6 服务器端和浏览器端都可以用，但都需要先编译打包所有用到的模块。支持 **webpack 插件异步加载**。
2）CommonJS 主要用于服务端 ，加载模块为同步，在浏览器中会造成阻塞。
3）AMD 和 CMD 都专供浏览器端，动态**异步**加载模块。

## async await 和 Promise

### promise.all 的 polyfill

## flex 布局，固定高度，左边定宽，右边自适应？

## 如果子元素不能 100%继承高度，怎么实现撑满？

## 对 ts 的理解

## ts 的泛型是什么作用

## 假如监控系统别的组需要用，并且没满足他们的需求，你会怎么处理

## 设计一个通过拖拽，然后交换位置的组件，给思路就可以。
