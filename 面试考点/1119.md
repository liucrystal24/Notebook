# 11-19 面试差漏补缺

## 一、暂存死区

暂存性死区是相对于某一个变量来说的，就是在定义该变量之前的区域就是暂存性死区

```js
let i = 0;
{
  // ----- 死区开始

  console.log(i); // 死区里无法拿到 i

  // ----- 死区结束
  let i = 1;
}
```

## 二、箭头函数 this 指向 call 、apply 、 bind 区别

箭头函数不会创建自己的 this,它只会从自己的作用域链的上一层继承 this。不能改变 this 指向

call / apply 立即执行， bind 不立即执行

**第二位** call ：参数用逗号分开，apply ：参数为数组，bind ： 不传入参数

- foo.call(obj,a,b);
- foo.apply(obj,[a,b]);
- foo.bind(obj);

## 三、双飞翼、圣杯布局

双飞翼、圣杯 都是三个 div 浮动，实现思路不同是

- 圣杯 中间 div 加上 padding 实现中间不被遮挡
- 双飞翼，中间层再添加一个 div，设置 margin 导致不被遮挡

flex 实现三栏布局

```css
.parent {
  display: flex;
}

.left,
.right {
  width: 200px;
}
.middle {
  flex: 1;
}
```

## 四、div 平均三等份

```css
/* calc */
.son {
  width: calc(100% / 3);
}
/* flex */
.parent {
  display: flex;
}
.son {
  flex: 1;
}
```

## 五、if 空数组对象的判断

if(a){}
if(Boolen(a))

除了 undefined,null,NaN,+0，-0，'', 其他均为 true，如 if({}){} if([]){}

## 七、vue 爷孙组件传值

通过 `provide` / `inject`

parent:

```vue
<div>
  <child :hello="hello"></child>
</div>

<script>
export default { provide: { foo: "爷爷传递的 " } };
</script>
```

son:

```vue
<div>
  我是孩子 这个父亲给我的{{ hello }}
  <grand></grand>
</div>

<script>
export default {
  props: { hello: { type: String, default: "" } },
  inject: ["foo"],
};
</script>
```

grandson:

```vue
<div>{{ foo }}</div>

<script>
export default { inject: ["foo"] };
</script>
```

## 八、Vue 生命周期，更好的理解、每个周期可以做的事情

## 九、vue 父子组件渲染顺序

https://blog.csdn.net/weixin_34344677/article/details/91381387

父组件 beforeCreated ->父组件 created ->父组件 beforeMounted
->子组件 beforeCreated ->子组件 created ->子组件 beforeMounted
->子组件 mounted -> 父组件 mounted。

## 九、更好的 Vue 理解双向绑定

## 十、Vue 路由守护钩子函数，拿到实例

## 十一、Vuex action 参数理解

## 十二、Vue nextTick（） 使用场景

## 十三、keep-alive

## 十四、路由跳转，参数和刷新以后的保存，hash 和 history 的区别

https://blog.csdn.net/bluefish_flying/article/details/81011230

## 十五、Promise 更深的理解

resolve 的是一个 Promise 对象：

```js
function cook() {
  console.log("开始做饭。");
  var p = new Promise(function (resolve, reject) {
    //做一些异步操作
    setTimeout(function () {
      console.log("做饭完毕！");
      resolve("鸡蛋炒饭");
    }, 1000);
  });
  return p;
}
```

data 是 ‘鸡蛋炒饭’ 字符串:

```js
console.log("开始做饭。");
var p = new Promise((resolve, reject) => {
  setTimeout(function () {
    console.log("做饭完成");
    resolve("鸡蛋炒饭");
  }, 2000);
}).then((data) => {
  console.log(data);
});
```

- 当 Promise 的回调函数返回非 Promise 对象的值时，then 和 catch 都生成一个状态为 fulfilled 的 Promise 对象，并把该返回值传入 Promise 链的下一环节。
- 当 Promise 的回调函数返回值为 Promise 对象时，生成的 Promise 对象的状态由被返回的 Promise 对象决定，传入 Promise 链下一环节的值也由这个被返回的 Promise 决定。
- 当 Promise 的回调函数中抛出错误时，then 和 catch 都生成一个状态为 reject 的 Promise 对象，并把抛出的错误对象传入 Promise 链的下一环节。

## axios 封装，request 拦截器

https://www.jianshu.com/p/a0c67f4e145e

## typeof instanceof

# 计划

差漏补缺

- 根据问题，搜索答案，查看 VueX，VueRouter 文档 （ 五+六 ）
- 查看项目（查找问题，看累的时候查看项目视频）https://www.bilibili.com/video/BV1Gz411z75G
